name: Spec Lint

on:
  pull_request:
    paths:
      - "_specs/**"

permissions:
  contents: read

jobs:
  lint:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with: { fetch-depth: 0 }

      - name: Get changed spec files
        id: changed
        uses: tj-actions/changed-files@v45
        with:
          files: |
            _specs/**.md
          separator: "\n"

      - name: Lint front-matter
        if: steps.changed.outputs.all_changed_files != ''
        run: |
          set -euo pipefail

          files="${{ steps.changed.outputs.all_changed_files }}"
          echo "Changed files:"
          printf '%s\n' "$files"

          get_fm() { # print YAML front-matter (no ---)
            awk 'NR==1&&$0=="---"{in=1;next} in{ if($0=="---"){exit} print }' "$1"
          }
          val() { # get scalar value by key (first occurrence, case-insensitive)
            printf '%s\n' "$2" | awk -F':[ \t]*' -v k="$1" 'BEGIN{IGNORECASE=1} $1==k{print $2; exit}'
          }

          err=0
          # File-level checks
          while IFS= read -r f; do
            [ -f "$f" ] || continue
            fm="$(get_fm "$f")"

            layout=$(val layout "$fm")
            [ "$layout" = "spec" ] || { echo "::error file=$f::layout must be 'spec'"; err=1; }

            nav_title=$(val nav_title "$fm")
            nav_order=$(val nav_order "$fm")

            if [[ "$f" == _specs/*/*/index.md ]]; then
              id=$(val id "$fm")
              status=$(val status "$fm")
              owner=$(val owner "$fm")
              created_at=$(val created_at "$fm")
              updated_at=$(val updated_at "$fm")

              [[ "$id" =~ ^[0-9]+$ ]] || { echo "::error file=$f::id must be integer"; err=1; }
              case "$status" in in-progress|active|deprecated) ;; *) echo "::error file=$f::status must be in-progress|active|deprecated"; err=1;; esac
              [ -n "$owner" ] || { echo "::error file=$f::owner missing"; err=1; }
              [[ "$created_at" =~ ^[0-9]{4}-[0-9]{2}-[0-9]{2}$ ]] || { echo "::error file=$f::created_at must be YYYY-MM-DD"; err=1; }
              [[ "$updated_at" =~ ^[0-9]{4}-[0-9]{2}-[0-9]{2}$ ]] || { echo "::error file=$f::updated_at must be YYYY-MM-DD"; err=1; }
              [ "$nav_title" = "Overview" ] || { echo "::error file=$f::index.md nav_title must be 'Overview'"; err=1; }
              [ "$nav_order" = "0" ] || { echo "::error file=$f::index.md nav_order must be 0"; err=1; }
            else
              [ -n "$nav_title" ] || { echo "::error file=$f::nav_title missing"; err=1; }
              [[ "$nav_order" =~ ^[0-9]+$ ]] || { echo "::error file=$f::nav_order must be integer"; err=1; }
            fi
          done <<< "$files"

          # Directory-level checks: unique nav_order per space
          for dir in $(echo "$files" | sed -n 's@^\(_specs/[^/]\+/[^/]\+\)/.*@\1@p' | sort -u); do
            orders=$(grep -RhoE '^nav_order:\s*[0-9]+' "$dir"/*.md 2>/dev/null | awk '{print $2}')
            dups=$(echo "$orders" | sort -n | uniq -d || true)
            if [ -n "$dups" ]; then
              echo "::error file=$dir::Duplicate nav_order values in $dir â†’ $dups"
              err=1
            fi
          done

          exit $err
